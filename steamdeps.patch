diff -dur steam.orig/steamdeps steam/steamdeps
--- steam.orig/steamdeps	2014-02-11 01:25:25.000000000 +0100
+++ steam/steamdeps	2015-02-08 13:53:00.628717189 +0100
@@ -20,21 +20,91 @@
 # This is the set of supported dependency formats
 SUPPORTED_STEAM_DEPENDENCY_VERSION = [ '1' ]
 
+ARCH = "i686" # updated during package build
+
+PLD_PACKAGE_MAP = {
+        "python-apt": None,
+        "xz-utils": "xz",
+
+        "libc6": "glibc",
+        "libc6:i386": "@libc.so.6(GLIBC_2.15)",
+        "libc6:amd64": "@libc.so.6(GLIBC_2.15)(64bit)",
+
+        # different libGL implementation pull different drivers & dependencies
+        "libgl1-mesa-dri:i386": "@libGL.so.1",
+        "libgl1-mesa-glx:i386": "@libGL.so.1",
+        }
+
+if "64" in ARCH:
+        PLD_PACKAGE_MAP["libgl1-mesa-dri"] = "@libGL.so.1()(64bit)"
+        PLD_PACKAGE_MAP["libgl1-mesa-glx"] = "@libGL.so.1()(64bit)"
+else:
+        PLD_PACKAGE_MAP["libgl1-mesa-dri"] = "@libGL.so.1"
+        PLD_PACKAGE_MAP["libgl1-mesa-glx"] = "@libGL.so.1"
+
+PLD_ARCH_MAP = {
+        "x86_64": "amd64",
+        "i486": "i386",
+        "i586": "i386",
+        "i686": "i386",
+        }
+
+PLD_PKGNAME_RE = re.compile(r"^(.*)-([^-]*)-([^-]*?)(?:\.([^-]*))?$")
+
+PLD_CONFIG_FN = "/etc/sysconfig/steam-launcher"
+
+_config = None
+def pld_get_config():
+	"""Load the sysconfig file. Accept shell-like syntax."""
+	global _config
+	if _config is not None:
+		return _config
+	config = {}
+	try:
+		with open(PLD_CONFIG_FN) as config_f:
+			for line in config_f:
+				line = line.strip()
+				if not line or line.startswith("#"):
+					continue
+				if "=" not in line:
+					print >>sys.stderr, "{0}: syntax error: {1!r}".format(PLD_CONFIG_FN, line)
+					continue
+				key, value = line.split("=", 1)
+				key = key.strip()
+				value = value.strip()
+				if value.startswith('"'):
+					if value.endswith('"'):
+						value = value[1:-1]
+					else:
+						print >>sys.stderr, "{0}: syntax error: {1!r}".format(PLD_CONFIG_FN, line)
+						continue
+				config[key] = value
+	except IOError as err:
+		print >>sys.stderr, "{0}: {1}".format(PLD_CONFIG_FN, err)
+	_config = config
+	return config
+
+def pld_config_enabled(variable, default=False):
+	config = pld_get_config()
+	value = config.get(variable, default)
+	if value in (True, False):
+		return value
+	return value.lower() in ("yes", "true", "on")
+
+def pld_config_get(variable, default=None):
+	config = pld_get_config()
+	return config.get(variable, default)
+
 ###
 # Get the current package architecture
 # This may be different than the actual architecture for the case of i386
 # chroot environments on amd64 hosts.
-_arch = None
+# PLD: use the architecture the steam-launcher package was built for
 def getArch():
 	"""
 	Get the current architecture
 	"""
-	global _arch
-
-	if ( _arch is None ):
-		_arch = subprocess.check_output(['dpkg', '--print-architecture']).decode("utf-8").strip()
-	return _arch
-
+        return PLD_ARCH_MAP[ARCH]
 
 ###
 def getFullPackageName( name ):
@@ -51,23 +121,27 @@
 # N.B. Version checks are not supported on virtual packages
 #
 def isProvided(pkgname):
-	try:
-		process = subprocess.Popen( ['apt-cache', 'showpkg', pkgname], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-		pattern = re.compile( r'^Reverse Provides\:')
-		providers = {}
-		for line in process.stdout:
-			if re.match(pattern,line):
-				for provider in process.stdout:
-					(name, version) = provider.split()
-					providers[name] = version
-				for provider in providers.keys():
-					if hasPackage(provider):
-						return True
-				return False
-	except:
-		return False
-	return False
+        if ":" in pkgname:
+            pkgname, arch = pkgname.split(":", 1)
+        else:
+	    arch = None
 
+        if pkgname.startswith("@"):
+            pkgname = pkgname[1:]
+
+	process = subprocess.Popen(['rpm', '-q', '--what-provides', pkgname],
+                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+	for line in process.stdout:
+		line = line.decode( "utf-8" ).strip()
+		match = PLD_PKGNAME_RE.match(line)
+		if ( match is None ):
+			continue
+                pkg_arch = match.group(4)
+                if arch and pkg_arch and PLD_ARCH_MAP[pkg_arch] != arch:
+	            print "bad arch {0!r}!={1!r}".format(PLD_ARCH_MAP[pkg_arch], arch)
+                    continue
+		return True
+	return False
 
 ###
 class Package:
@@ -89,8 +163,17 @@
 			return isProvided(self.name)
 
 		for (op, version) in self.versionConditions:
-			if ( subprocess.call( ['dpkg', '--compare-versions', self.installed, op, version] ) != 0 ):
-				return False
+                    rc = subprocess.call(['rpmvercmp', self.installed, version], stdout=open("/dev/null","w") )
+                    if op in ("=", "==") and rc != 0:
+                        return False
+                    if op == ">" and rc != 1:
+                        return False
+                    if op == ">=" and rc not in (0, 1):
+                        return False
+                    if op == "<" and rc != 2:
+                        return False
+                    if op == "<=" and rc not in (0, 2):
+                        return False
 
 		return True
 
@@ -103,20 +186,12 @@
 
 ###
 def hasPackage( package ):
-	process = subprocess.Popen( ['dpkg', '-l', package], stdout=subprocess.PIPE, stderr=subprocess.PIPE )
-	installed_pattern = re.compile( r"^\Si\s+([^\s]+)\s+([^\s]+)" )
-	for line in process.stdout:
-		line = line.decode( "utf-8" ).strip()
-		match = re.match( installed_pattern, line )
-		if ( match is None ):
-			continue
-
-		return True
-	return False
-
+    return isProvided(package)
 
 def remapPackage( description ):
 
+        return description
+
 	# Ubuntu 12.04.2, 12.04.3, and 12.04.4 introduce new X stacks which require 
 	# different sets of incompatible glx packages depending on which X 
 	# is currently installed.
@@ -186,12 +261,14 @@
 	"""
 	if ( "DISPLAY" in os.environ ):
 		programs = [
-			( "gnome-terminal", ["gnome-terminal", "--disable-factory", "-t", title, "-e"] ),
+                        # PLD: --disable-factory doesn't work any more
+			#( "gnome-terminal", ["gnome-terminal", "--disable-factory", "-t", title, "-e"] ),
 			( "konsole", ["konsole", "--nofork", "-p", "tabtitle="+title, "-e"] ),
+			( "Terminal", ["Terminal", "--disable-server", "--title="+title, "-x"] ),
 			( "xterm", ["xterm", "-bg", "#383635", "-fg", "#d1cfcd", "-T", title, "-e"] ),
 		]
 		for (program, commandLine) in programs:
-			if ( subprocess.call( ['which', program], stdout=subprocess.PIPE ) == 0 ):
+			if ( subprocess.call( ['which', program], stdout=subprocess.PIPE, stderr=open("/dev/null", "w") ) == 0 ):
 				return commandLine
 
 	# Fallback if no GUI terminal program is available
@@ -205,17 +282,21 @@
 	Ideally we would call some sort of system UI that users were familiar with to do this, but nothing that exists yet does what we need.
 	"""
 
-	packageList = " ".join( [ package.name for package in packages ] )
-
 	# Create a temporary file to hold the installation completion status
 	(fd, statusFile) = tempfile.mkstemp()
 	os.close( fd )
 
+        # Create a poldek pset file to allow installing virtual deps
+	psetFile = tempfile.NamedTemporaryFile("w")
+        for package in packages:
+            print >> psetFile, package.name
+        psetFile.flush()
+
 	# Create a script to run, in a secure way
 	(fd, scriptFile) = tempfile.mkstemp()
-	script = """#!/bin/sh
+	script = """#!/bin/sh{sh_flag}
 check_sudo()
-{
+{{
     # If your host file is misconfigured in certain circumstances this
     # can cause sudo to block for a while, which causes gksudo to go into
     # limbo and never return.
@@ -231,29 +312,30 @@
     else
         return 0
     fi
-}
+}}
 
 cat <<__EOF__
 Steam needs to install these additional packages: 
-	%s
+	{pkg_list}
 __EOF__
-check_sudo
-
-# Check to make sure 64-bit systems can get 32-bit packages
-if [ "$(dpkg --print-architecture)" = "amd64" ] && ! dpkg --print-foreign-architectures | grep i386 >/dev/null; then
-    sudo dpkg --add-architecture i386
-fi
+[ -n "{sudo}" ] && check_sudo
 
 # Update the package list, showing progress
-sudo apt-get update | while read line; do echo -n "."; done
+{sudo} poldek {poldek_options} --up
 echo
 
 # Install the packages!
-sudo apt-get install %s
-echo $? >%s
+{sudo} poldek {poldek_options} -u --pset={pset}
+echo $? >{status_file}
 echo -n "Press return to continue: "
 read line
-""" % ( ", ".join( [ package.name for package in packages ] ), packageList, statusFile )
+""".format(
+		pkg_list = ", ".join( [ package.name for package in packages ] ),
+		pset=psetFile.name,
+		status_file=statusFile,
+		sh_flag=" -x" if pld_config_enabled("DEBUG") else "",
+		sudo="sudo" if pld_config_enabled("USE_SUDO") else "",
+		poldek_options=pld_config_get("POLDEK_OPTIONS", ""))
 	os.write( fd, script.encode("utf-8") )
 	os.close( fd )
 	os.chmod( scriptFile, (stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR) )
@@ -263,6 +345,7 @@
 	except KeyboardInterrupt:
 		pass
 	os.unlink( scriptFile )
+        psetFile.close()
 
 	# Read the status out of the file, since if we ran the script in a
 	# terminal the process status will be whether the terminal started
@@ -274,6 +357,9 @@
 
 	os.unlink( statusFile )
 
+	if status:
+		print "\nWARNING: dependencies install failed!\n"
+
 	return status
 
 
@@ -295,11 +381,11 @@
 		sys.stderr.write( "Unsupported dependency version: %s\n" % config["STEAM_DEPENDENCY_VERSION"] )
 		return False
 
-	# Make sure we can use dpkg on this system.
+	# Make sure we can use rpm on this system.
 	try:
-		subprocess.call( ['dpkg', '--version'], stdout=subprocess.PIPE )
+		subprocess.call( ['rpm', '--version'], stdout=subprocess.PIPE )
 	except:
-		sys.stderr.write( "Couldn't find dpkg, please update steamdeps for your distribution.\n" )
+		sys.stderr.write( "Couldn't find rpm, please update steamdeps for your distribution.\n" )
 		return False
 
 	return True
@@ -314,7 +400,11 @@
 		sys.stderr.write( "Usage: %s dependencies.txt\n" % sys.argv[0] )
 		return 1
 
-	# Make sure we can open the file
+	# disable steam runtime, so their libs won't conflict our binaries
+	os.unsetenv("LD_LIBRARY_PATH")
+	os.unsetenv("LD_PRELOAD")
+
+        # Make sure we can open the file
 	try:
 		fp = open(sys.argv[1])
 	except Exception as e:
@@ -355,10 +445,20 @@
 	
 		row = []
 		for section in line.split( "|" ):
-			package = createPackage( section )
+                        pld_pkg = PLD_PACKAGE_MAP.get(section, section)
+                        if not pld_pkg:
+                            continue
+
+			package = createPackage( pld_pkg )
 			if ( package is None ):
 				continue
 
+                        if package.name in packages:
+                            existing = packages[package.name]
+                            if existing.versionConditions == package.versionConditions:
+                                row.append( existing )
+                                continue
+
 			packages[ package.name ] = package
 			row.append( package )
 
@@ -375,32 +475,43 @@
 	if ( "COLUMNS" in os.environ ):
 		del os.environ[ "COLUMNS" ]
 
-	process = subprocess.Popen( ['dpkg', '-l'] + list( packages.keys() ), stdout=subprocess.PIPE, stderr=subprocess.PIPE )
-	installed_pattern = re.compile( r"^\Si\s+([^\s]+)\s+([^\s]+)" )
+        pkg_names = [name.split(":", 1)[0] for name in packages.keys() if not name.startswith("@")]
+	process = subprocess.Popen( ['rpm', '-q'] + pkg_names, stdout=subprocess.PIPE, stderr=subprocess.PIPE )
 	for line in process.stdout:
 		line = line.decode( "utf-8" ).strip()
-		match = re.match( installed_pattern, line )
+
+                match = PLD_PKGNAME_RE.match(line)
 		if ( match is None ):
 			continue
 
 		name = match.group(1)
-		if ( name not in packages ):
+		if name not in packages:
+                    if match.group(4):
+                        arch = PLD_ARCH_MAP[match.group(4)]
+                        name = "{0}:{1}".format(name, arch)
+                    else:
 			name = getFullPackageName( name )
+                    if name not in packages:
+                        continue
+
 		packages[ name ].setInstalled( match.group(2) )
 
 	# See which ones need to be installed
-	needed = []
+	consider_installed = pld_config_get("INSTALLED", "").split()
+	needed = set()
 	for row in dependencies:
 		if ( len(row) == 0 ):
 			continue
-
 		satisfied = False
 		for dep in row:
 			if ( dep.isAvailable() ):
 				satisfied = True
 				break
 		if ( not satisfied ):
-			needed.append( row[0] )
+			if row[0].name not in consider_installed:
+				needed.add( row[0] )
+			else:
+				print("Considering {0} already installed".format(row[0].name))
 
 	# If we have anything to install, do it!
 	if ( len(needed) > 0 ):
@@ -409,8 +520,12 @@
 				print( "Package %s is installed with version '%s' but doesn't match requirements: %s" % (package.name, package.installed, package) )
 			else:
 				print( "Package %s needs to be installed" % package.name )
-
-		return updatePackages( needed )
+		if pld_config_enabled("INSTALL_PACKAGES", True):
+			print("Installing packages as configured through {0}...".format(PLD_CONFIG_FN))
+			return updatePackages( needed )
+		else:
+			print("\nWARNING: Dependencies missing, but package install disabled through {0}\n".format(PLD_CONFIG_FN))
+			return 1
 	else:
 		return 0
 
