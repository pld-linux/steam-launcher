diff -dur steam.orig/steamdeps steam/steamdeps
--- steam.orig/steamdeps	2014-02-11 01:25:25.000000000 +0100
+++ steam/steamdeps	2014-06-12 10:44:00.000000000 +0200
@@ -20,21 +20,47 @@
 # This is the set of supported dependency formats
 SUPPORTED_STEAM_DEPENDENCY_VERSION = [ '1' ]
 
+ARCH = "i686" # updated during package build
+
+PLD_PACKAGE_MAP = {
+        "python-apt": None,
+        "xz-utils": "xz",
+
+        "libc6": "glibc",
+        "libc6:i386": "@libc.so.6(GLIBC_2.15)",
+        "libc6:amd64": "@libc.so.6(GLIBC_2.15)(64bit)",
+
+        # different libGL implementation pull different drivers & dependencies
+        "libgl1-mesa-dri:i386": "@libGL.so.1",
+        "libgl1-mesa-glx:i386": "@libGL.so.1",
+        }
+
+if "64" in ARCH:
+        PLD_PACKAGE_MAP["libgl1-mesa-dri"] = "@libGL.so.1()(64bit)"
+        PLD_PACKAGE_MAP["libgl1-mesa-glx"] = "@libGL.so.1()(64bit)"
+else:
+        PLD_PACKAGE_MAP["libgl1-mesa-dri"] = "@libGL.so.1"
+        PLD_PACKAGE_MAP["libgl1-mesa-glx"] = "@libGL.so.1"
+
+PLD_ARCH_MAP = {
+        "x86_64": "amd64",
+        "i486": "i386",
+        "i586": "i386",
+        "i686": "i386",
+        }
+
+PLD_PKGNAME_RE = re.compile(r"^(.*)-([^-]*)-([^-]*?)(?:\.([^-]*))?$")
+
 ###
 # Get the current package architecture
 # This may be different than the actual architecture for the case of i386
 # chroot environments on amd64 hosts.
-_arch = None
+# PLD: use the architecture the steam-launcher package was built for
 def getArch():
 	"""
 	Get the current architecture
 	"""
-	global _arch
-
-	if ( _arch is None ):
-		_arch = subprocess.check_output(['dpkg', '--print-architecture']).decode("utf-8").strip()
-	return _arch
-
+        return PLD_ARCH_MAP[ARCH]
 
 ###
 def getFullPackageName( name ):
@@ -51,23 +77,26 @@
 # N.B. Version checks are not supported on virtual packages
 #
 def isProvided(pkgname):
-	try:
-		process = subprocess.Popen( ['apt-cache', 'showpkg', pkgname], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-		pattern = re.compile( r'^Reverse Provides\:')
-		providers = {}
-		for line in process.stdout:
-			if re.match(pattern,line):
-				for provider in process.stdout:
-					(name, version) = provider.split()
-					providers[name] = version
-				for provider in providers.keys():
-					if hasPackage(provider):
-						return True
-				return False
-	except:
-		return False
-	return False
+        if ":" in pkgname:
+            pkgname, arch = pkgname.split(":", 1)
+        else:
+            arch = PLD_ARCH_MAP[ARCH]
+
+        if pkgname.startswith("@"):
+            pkgname = pkgname[1:]
 
+	process = subprocess.Popen(['rpm', '-q', '--what-provides', pkgname],
+                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+	for line in process.stdout:
+		line = line.decode( "utf-8" ).strip()
+		match = PLD_PKGNAME_RE.match(line)
+		if ( match is None ):
+			continue
+                pkg_arch = match.group(4)
+                if pkg_arch and PLD_ARCH_MAP[pkg_arch] != arch:
+                    continue
+		return True
+	return False
 
 ###
 class Package:
@@ -89,8 +118,17 @@
 			return isProvided(self.name)
 
 		for (op, version) in self.versionConditions:
-			if ( subprocess.call( ['dpkg', '--compare-versions', self.installed, op, version] ) != 0 ):
-				return False
+                    rc = subprocess.call(['rpmvercmp', self.installed, version], stdout=open("/dev/null","w") )
+                    if op in ("=", "==") and rc != 0:
+                        return False
+                    if op == ">" and rc != 1:
+                        return False
+                    if ope == ">=" and rc not in (0, 1):
+                        return False
+                    if op == "<" and rc != 2:
+                        return False
+                    if ope == "<=" and rc not in (0, 2):
+                        return False
 
 		return True
 
@@ -103,20 +141,12 @@
 
 ###
 def hasPackage( package ):
-	process = subprocess.Popen( ['dpkg', '-l', package], stdout=subprocess.PIPE, stderr=subprocess.PIPE )
-	installed_pattern = re.compile( r"^\Si\s+([^\s]+)\s+([^\s]+)" )
-	for line in process.stdout:
-		line = line.decode( "utf-8" ).strip()
-		match = re.match( installed_pattern, line )
-		if ( match is None ):
-			continue
-
-		return True
-	return False
-
+    return isProvided(package)
 
 def remapPackage( description ):
 
+        return description
+
 	# Ubuntu 12.04.2, 12.04.3, and 12.04.4 introduce new X stacks which require 
 	# different sets of incompatible glx packages depending on which X 
 	# is currently installed.
@@ -186,12 +216,14 @@
 	"""
 	if ( "DISPLAY" in os.environ ):
 		programs = [
-			( "gnome-terminal", ["gnome-terminal", "--disable-factory", "-t", title, "-e"] ),
+                        # PLD: --disable-factory doesn't work any more
+			#( "gnome-terminal", ["gnome-terminal", "--disable-factory", "-t", title, "-e"] ),
 			( "konsole", ["konsole", "--nofork", "-p", "tabtitle="+title, "-e"] ),
+			( "Terminal", ["Terminal", "--disable-server", "--title="+title, "-x"] ),
 			( "xterm", ["xterm", "-bg", "#383635", "-fg", "#d1cfcd", "-T", title, "-e"] ),
 		]
 		for (program, commandLine) in programs:
-			if ( subprocess.call( ['which', program], stdout=subprocess.PIPE ) == 0 ):
+			if ( subprocess.call( ['which', program], stdout=subprocess.PIPE, stderr=open("/dev/null", "w") ) == 0 ):
 				return commandLine
 
 	# Fallback if no GUI terminal program is available
@@ -205,12 +237,16 @@
 	Ideally we would call some sort of system UI that users were familiar with to do this, but nothing that exists yet does what we need.
 	"""
 
-	packageList = " ".join( [ package.name for package in packages ] )
-
 	# Create a temporary file to hold the installation completion status
 	(fd, statusFile) = tempfile.mkstemp()
 	os.close( fd )
 
+        # Create a poldek pset file to allow installing virtual deps
+	psetFile = tempfile.NamedTemporaryFile("w")
+        for package in packages:
+            print >> psetFile, package.name
+        psetFile.flush()
+
 	# Create a script to run, in a secure way
 	(fd, scriptFile) = tempfile.mkstemp()
 	script = """#!/bin/sh
@@ -239,21 +275,16 @@
 __EOF__
 check_sudo
 
-# Check to make sure 64-bit systems can get 32-bit packages
-if [ "$(dpkg --print-architecture)" = "amd64" ] && ! dpkg --print-foreign-architectures | grep i386 >/dev/null; then
-    sudo dpkg --add-architecture i386
-fi
-
 # Update the package list, showing progress
-sudo apt-get update | while read line; do echo -n "."; done
+sudo poldek --up
 echo
 
 # Install the packages!
-sudo apt-get install %s
+sudo poldek -u --pset=%s
 echo $? >%s
 echo -n "Press return to continue: "
 read line
-""" % ( ", ".join( [ package.name for package in packages ] ), packageList, statusFile )
+""" % ( ", ".join( [ package.name for package in packages ] ), psetFile.name, statusFile )
 	os.write( fd, script.encode("utf-8") )
 	os.close( fd )
 	os.chmod( scriptFile, (stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR) )
@@ -263,6 +294,7 @@
 	except KeyboardInterrupt:
 		pass
 	os.unlink( scriptFile )
+        psetFile.close()
 
 	# Read the status out of the file, since if we ran the script in a
 	# terminal the process status will be whether the terminal started
@@ -295,11 +327,11 @@
 		sys.stderr.write( "Unsupported dependency version: %s\n" % config["STEAM_DEPENDENCY_VERSION"] )
 		return False
 
-	# Make sure we can use dpkg on this system.
+	# Make sure we can use rpm on this system.
 	try:
-		subprocess.call( ['dpkg', '--version'], stdout=subprocess.PIPE )
+		subprocess.call( ['rpm', '--version'], stdout=subprocess.PIPE )
 	except:
-		sys.stderr.write( "Couldn't find dpkg, please update steamdeps for your distribution.\n" )
+		sys.stderr.write( "Couldn't find rpm, please update steamdeps for your distribution.\n" )
 		return False
 
 	return True
@@ -355,10 +387,20 @@
 	
 		row = []
 		for section in line.split( "|" ):
-			package = createPackage( section )
+                        pld_pkg = PLD_PACKAGE_MAP.get(section, section)
+                        if not pld_pkg:
+                            continue
+
+			package = createPackage( pld_pkg )
 			if ( package is None ):
 				continue
 
+                        if package.name in packages:
+                            existing = packages[package.name]
+                            if existing.versionConditions == package.versionConditions:
+                                row.append( existing )
+                                continue
+
 			packages[ package.name ] = package
 			row.append( package )
 
@@ -375,32 +417,39 @@
 	if ( "COLUMNS" in os.environ ):
 		del os.environ[ "COLUMNS" ]
 
-	process = subprocess.Popen( ['dpkg', '-l'] + list( packages.keys() ), stdout=subprocess.PIPE, stderr=subprocess.PIPE )
-	installed_pattern = re.compile( r"^\Si\s+([^\s]+)\s+([^\s]+)" )
+        pkg_names = [name.split(":", 1)[0] for name in packages.keys() if not name.startswith("@")]
+	process = subprocess.Popen( ['rpm', '-q'] + pkg_names, stdout=subprocess.PIPE, stderr=subprocess.PIPE )
 	for line in process.stdout:
 		line = line.decode( "utf-8" ).strip()
-		match = re.match( installed_pattern, line )
+
+                match = PLD_PKGNAME_RE.match(line)
 		if ( match is None ):
 			continue
 
 		name = match.group(1)
-		if ( name not in packages ):
+		if name not in packages:
+                    if match.group(4):
+                        arch = PLD_ARCH_MAP[match.group(4)]
+                        name = "{0}:{1}".format(name, arch)
+                    else:
 			name = getFullPackageName( name )
+                    if name not in packages:
+                        continue
+
 		packages[ name ].setInstalled( match.group(2) )
 
 	# See which ones need to be installed
-	needed = []
+	needed = set()
 	for row in dependencies:
 		if ( len(row) == 0 ):
 			continue
-
 		satisfied = False
 		for dep in row:
 			if ( dep.isAvailable() ):
 				satisfied = True
 				break
 		if ( not satisfied ):
-			needed.append( row[0] )
+			needed.add( row[0] )
 
 	# If we have anything to install, do it!
 	if ( len(needed) > 0 ):
